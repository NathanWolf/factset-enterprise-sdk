/*
 * FactSet Options API
 *
 * The Option Prices database provides pricing data such as mid bid-ask price, reference data (e.g., strike price), and risk measures (e.g., Greeks and implied volatility). Visit [Options Overview OA Page # 14925](https://my.apps.factset.com/oa/pages/14925) for details on database coverage. U.S. exchange-traded option bid and ask quotes are continuously updated throughout the day even when no trades have occurred on the option (zero volume). The end-of-day closing bid and ask quotes are always in line with the underlying closing price.  **Note** * Currently in Beta only **OPRA** exchanges are supported. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.FactSetOptions.Client.OpenAPIDateConverter;

namespace FactSet.SDK.FactSetOptions.Model
{
    /// <summary>
    /// Snapshot Response fields
    /// </summary>
    [DataContract(Name = "snapshot")]
    public partial class Snapshot : IEquatable<Snapshot>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Snapshot" /> class.
        /// </summary>
        /// <param name="fsymId">FactSet&#39;s Option Symbol. For more detail, visit [OA 12636](https://my.apps.factset.com/oa/pages/12636#options).</param>
        /// <param name="date">The date the data is as of in YYYY-MM-DD.</param>
        /// <param name="delta">The ratio comparing the change in the price of the underlying asset to the corresponding change in the price of a derivative. Sometimes referred to as the \&quot;hedge ratio\&quot;. For example, with respect to call options, a delta of 0.7 means that for every $1 the underlying stock increases, the call option will increase by $0.70. Put option deltas, on the other hand, will be negative, because as the underlying security increases, the value of the option will decrease. So a put option with a delta of -0.7 will decrease by $0.70 for every $1 the underlying increases in price. As an in-the-money call option nears expiration, it will approach a delta of 1.00, and as an in-the-money put option nears expiration, it will approach a delta of -1.00. .</param>
        /// <param name="expirationDate">The expiration date of the option contract in YYYY-MM-DD format.</param>
        /// <param name="impliedVolatility">The implied volatility for the option identifier. Visit [OA 14932](https://my.apps.factset.com/oa/pages/14932) .</param>
        /// <param name="name">The name of the option security..</param>
        /// <param name="openInterest">The total number of options and/or futures contracts that are not closed or delivered on a particular day..</param>
        /// <param name="price">The calculated price quote, based on the calculated status. For US Options - Returns \&quot;Ask Price\&quot; if calc status&#x3D;&#x3D;20, otherwise returns \&quot;Mid Bid/Ask Price\&quot;. For International Options - Returns \&quot;Settlement Price\&quot;. .</param>
        /// <param name="requestId">The input value for the id parameter..</param>
        /// <param name="style">Returns the style of the option id requested, where -   |style|description| |- --|- --| |0|American| |1|European|  An American style option can be exercised anytime during its life. The majority of exchange-traded options are American.   Since investors have the freedom to exercise their American options at any point during the life of the contract, they are more valuable than European options which can only be exercised at maturity.   Consider this example- If you bought a Ford March Call option expiring in March of 2006, in March 2005 you would have the right to exercise the call option at anytime up until its expiration date. Had the Ford option been a European option, you could only exercise the option at the expiry date in March 2006. During the year, the share price could have been most optimal for exercise in December of 2005, but you would have to wait to exercise your option until March 2006, where it could be out of the money and virtually worthless. The name of this option style has nothing to do with the geographic location. .</param>
        /// <param name="type">The option type code, where  |code|description| |- --|- --| |0|Equity Option| |2|Index Option| |99|Option on an ETF| |60|Option on a Future| |19|Option on a Spot FX Rate| .</param>
        /// <param name="underlyingFsymSecurityId">The Symbol of the security that must be delivered when a derivative contract, such as a put or call option, is exercised. This is represented in FactSet&#39;s Permanent Security Identifier format (XXXXXX-S). .</param>
        /// <param name="underlyingPrice">The price of the underyling security as of the date requested. .</param>
        public Snapshot(string fsymId = default(string), DateTime date = default(DateTime), double delta = default(double), DateTime expirationDate = default(DateTime), double impliedVolatility = default(double), string name = default(string), int openInterest = default(int), double price = default(double), string requestId = default(string), int style = default(int), int type = default(int), string underlyingFsymSecurityId = default(string), double underlyingPrice = default(double))
        {
            this.FsymId = fsymId;
            this.Date = date;
            this.Delta = delta;
            this.ExpirationDate = expirationDate;
            this.ImpliedVolatility = impliedVolatility;
            this.Name = name;
            this.OpenInterest = openInterest;
            this.Price = price;
            this.RequestId = requestId;
            this.Style = style;
            this.Type = type;
            this.UnderlyingFsymSecurityId = underlyingFsymSecurityId;
            this.UnderlyingPrice = underlyingPrice;
        }

        /// <summary>
        /// FactSet&#39;s Option Symbol. For more detail, visit [OA 12636](https://my.apps.factset.com/oa/pages/12636#options)
        /// </summary>
        /// <value>FactSet&#39;s Option Symbol. For more detail, visit [OA 12636](https://my.apps.factset.com/oa/pages/12636#options)</value>
        [DataMember(Name = "fsymId", EmitDefaultValue = false)]
        public string FsymId { get; set; }

        /// <summary>
        /// The date the data is as of in YYYY-MM-DD
        /// </summary>
        /// <value>The date the data is as of in YYYY-MM-DD</value>
        [DataMember(Name = "date", EmitDefaultValue = false)]
        [JsonConverter(typeof(OpenAPIDateConverter))]
        public DateTime Date { get; set; }

        /// <summary>
        /// The ratio comparing the change in the price of the underlying asset to the corresponding change in the price of a derivative. Sometimes referred to as the \&quot;hedge ratio\&quot;. For example, with respect to call options, a delta of 0.7 means that for every $1 the underlying stock increases, the call option will increase by $0.70. Put option deltas, on the other hand, will be negative, because as the underlying security increases, the value of the option will decrease. So a put option with a delta of -0.7 will decrease by $0.70 for every $1 the underlying increases in price. As an in-the-money call option nears expiration, it will approach a delta of 1.00, and as an in-the-money put option nears expiration, it will approach a delta of -1.00. 
        /// </summary>
        /// <value>The ratio comparing the change in the price of the underlying asset to the corresponding change in the price of a derivative. Sometimes referred to as the \&quot;hedge ratio\&quot;. For example, with respect to call options, a delta of 0.7 means that for every $1 the underlying stock increases, the call option will increase by $0.70. Put option deltas, on the other hand, will be negative, because as the underlying security increases, the value of the option will decrease. So a put option with a delta of -0.7 will decrease by $0.70 for every $1 the underlying increases in price. As an in-the-money call option nears expiration, it will approach a delta of 1.00, and as an in-the-money put option nears expiration, it will approach a delta of -1.00. </value>
        [DataMember(Name = "delta", EmitDefaultValue = false)]
        public double Delta { get; set; }

        /// <summary>
        /// The expiration date of the option contract in YYYY-MM-DD format
        /// </summary>
        /// <value>The expiration date of the option contract in YYYY-MM-DD format</value>
        [DataMember(Name = "expirationDate", EmitDefaultValue = false)]
        [JsonConverter(typeof(OpenAPIDateConverter))]
        public DateTime ExpirationDate { get; set; }

        /// <summary>
        /// The implied volatility for the option identifier. Visit [OA 14932](https://my.apps.factset.com/oa/pages/14932) 
        /// </summary>
        /// <value>The implied volatility for the option identifier. Visit [OA 14932](https://my.apps.factset.com/oa/pages/14932) </value>
        [DataMember(Name = "impliedVolatility", EmitDefaultValue = false)]
        public double ImpliedVolatility { get; set; }

        /// <summary>
        /// The name of the option security.
        /// </summary>
        /// <value>The name of the option security.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        public string Name { get; set; }

        /// <summary>
        /// The total number of options and/or futures contracts that are not closed or delivered on a particular day.
        /// </summary>
        /// <value>The total number of options and/or futures contracts that are not closed or delivered on a particular day.</value>
        [DataMember(Name = "openInterest", EmitDefaultValue = false)]
        public int OpenInterest { get; set; }

        /// <summary>
        /// The calculated price quote, based on the calculated status. For US Options - Returns \&quot;Ask Price\&quot; if calc status&#x3D;&#x3D;20, otherwise returns \&quot;Mid Bid/Ask Price\&quot;. For International Options - Returns \&quot;Settlement Price\&quot;. 
        /// </summary>
        /// <value>The calculated price quote, based on the calculated status. For US Options - Returns \&quot;Ask Price\&quot; if calc status&#x3D;&#x3D;20, otherwise returns \&quot;Mid Bid/Ask Price\&quot;. For International Options - Returns \&quot;Settlement Price\&quot;. </value>
        [DataMember(Name = "price", EmitDefaultValue = false)]
        public double Price { get; set; }

        /// <summary>
        /// The input value for the id parameter.
        /// </summary>
        /// <value>The input value for the id parameter.</value>
        [DataMember(Name = "requestId", EmitDefaultValue = false)]
        public string RequestId { get; set; }

        /// <summary>
        /// Returns the style of the option id requested, where -   |style|description| |- --|- --| |0|American| |1|European|  An American style option can be exercised anytime during its life. The majority of exchange-traded options are American.   Since investors have the freedom to exercise their American options at any point during the life of the contract, they are more valuable than European options which can only be exercised at maturity.   Consider this example- If you bought a Ford March Call option expiring in March of 2006, in March 2005 you would have the right to exercise the call option at anytime up until its expiration date. Had the Ford option been a European option, you could only exercise the option at the expiry date in March 2006. During the year, the share price could have been most optimal for exercise in December of 2005, but you would have to wait to exercise your option until March 2006, where it could be out of the money and virtually worthless. The name of this option style has nothing to do with the geographic location. 
        /// </summary>
        /// <value>Returns the style of the option id requested, where -   |style|description| |- --|- --| |0|American| |1|European|  An American style option can be exercised anytime during its life. The majority of exchange-traded options are American.   Since investors have the freedom to exercise their American options at any point during the life of the contract, they are more valuable than European options which can only be exercised at maturity.   Consider this example- If you bought a Ford March Call option expiring in March of 2006, in March 2005 you would have the right to exercise the call option at anytime up until its expiration date. Had the Ford option been a European option, you could only exercise the option at the expiry date in March 2006. During the year, the share price could have been most optimal for exercise in December of 2005, but you would have to wait to exercise your option until March 2006, where it could be out of the money and virtually worthless. The name of this option style has nothing to do with the geographic location. </value>
        [DataMember(Name = "style", EmitDefaultValue = false)]
        public int Style { get; set; }

        /// <summary>
        /// The option type code, where  |code|description| |- --|- --| |0|Equity Option| |2|Index Option| |99|Option on an ETF| |60|Option on a Future| |19|Option on a Spot FX Rate| 
        /// </summary>
        /// <value>The option type code, where  |code|description| |- --|- --| |0|Equity Option| |2|Index Option| |99|Option on an ETF| |60|Option on a Future| |19|Option on a Spot FX Rate| </value>
        [DataMember(Name = "type", EmitDefaultValue = false)]
        public int Type { get; set; }

        /// <summary>
        /// The Symbol of the security that must be delivered when a derivative contract, such as a put or call option, is exercised. This is represented in FactSet&#39;s Permanent Security Identifier format (XXXXXX-S). 
        /// </summary>
        /// <value>The Symbol of the security that must be delivered when a derivative contract, such as a put or call option, is exercised. This is represented in FactSet&#39;s Permanent Security Identifier format (XXXXXX-S). </value>
        [DataMember(Name = "underlyingFsymSecurityId", EmitDefaultValue = false)]
        public string UnderlyingFsymSecurityId { get; set; }

        /// <summary>
        /// The price of the underyling security as of the date requested. 
        /// </summary>
        /// <value>The price of the underyling security as of the date requested. </value>
        [DataMember(Name = "underlyingPrice", EmitDefaultValue = false)]
        public double UnderlyingPrice { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Snapshot {\n");
            sb.Append("  FsymId: ").Append(FsymId).Append("\n");
            sb.Append("  Date: ").Append(Date).Append("\n");
            sb.Append("  Delta: ").Append(Delta).Append("\n");
            sb.Append("  ExpirationDate: ").Append(ExpirationDate).Append("\n");
            sb.Append("  ImpliedVolatility: ").Append(ImpliedVolatility).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  OpenInterest: ").Append(OpenInterest).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  RequestId: ").Append(RequestId).Append("\n");
            sb.Append("  Style: ").Append(Style).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  UnderlyingFsymSecurityId: ").Append(UnderlyingFsymSecurityId).Append("\n");
            sb.Append("  UnderlyingPrice: ").Append(UnderlyingPrice).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Snapshot);
        }

        /// <summary>
        /// Returns true if Snapshot instances are equal
        /// </summary>
        /// <param name="input">Instance of Snapshot to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Snapshot input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.FsymId == input.FsymId ||
                    (this.FsymId != null &&
                    this.FsymId.Equals(input.FsymId))
                ) && 
                (
                    this.Date == input.Date ||
                    (this.Date != null &&
                    this.Date.Equals(input.Date))
                ) && 
                (
                    this.Delta == input.Delta ||
                    this.Delta.Equals(input.Delta)
                ) && 
                (
                    this.ExpirationDate == input.ExpirationDate ||
                    (this.ExpirationDate != null &&
                    this.ExpirationDate.Equals(input.ExpirationDate))
                ) && 
                (
                    this.ImpliedVolatility == input.ImpliedVolatility ||
                    this.ImpliedVolatility.Equals(input.ImpliedVolatility)
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.OpenInterest == input.OpenInterest ||
                    this.OpenInterest.Equals(input.OpenInterest)
                ) && 
                (
                    this.Price == input.Price ||
                    this.Price.Equals(input.Price)
                ) && 
                (
                    this.RequestId == input.RequestId ||
                    (this.RequestId != null &&
                    this.RequestId.Equals(input.RequestId))
                ) && 
                (
                    this.Style == input.Style ||
                    this.Style.Equals(input.Style)
                ) && 
                (
                    this.Type == input.Type ||
                    this.Type.Equals(input.Type)
                ) && 
                (
                    this.UnderlyingFsymSecurityId == input.UnderlyingFsymSecurityId ||
                    (this.UnderlyingFsymSecurityId != null &&
                    this.UnderlyingFsymSecurityId.Equals(input.UnderlyingFsymSecurityId))
                ) && 
                (
                    this.UnderlyingPrice == input.UnderlyingPrice ||
                    this.UnderlyingPrice.Equals(input.UnderlyingPrice)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.FsymId != null)
                {
                    hashCode = (hashCode * 59) + this.FsymId.GetHashCode();
                }
                if (this.Date != null)
                {
                    hashCode = (hashCode * 59) + this.Date.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Delta.GetHashCode();
                if (this.ExpirationDate != null)
                {
                    hashCode = (hashCode * 59) + this.ExpirationDate.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.ImpliedVolatility.GetHashCode();
                if (this.Name != null)
                {
                    hashCode = (hashCode * 59) + this.Name.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.OpenInterest.GetHashCode();
                hashCode = (hashCode * 59) + this.Price.GetHashCode();
                if (this.RequestId != null)
                {
                    hashCode = (hashCode * 59) + this.RequestId.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Style.GetHashCode();
                hashCode = (hashCode * 59) + this.Type.GetHashCode();
                if (this.UnderlyingFsymSecurityId != null)
                {
                    hashCode = (hashCode * 59) + this.UnderlyingFsymSecurityId.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.UnderlyingPrice.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
