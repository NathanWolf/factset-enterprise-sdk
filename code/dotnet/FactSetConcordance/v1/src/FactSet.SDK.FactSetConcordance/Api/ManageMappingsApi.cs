/*
 * FactSet Concordance API
 *
 * The FactSet Concordance API provides the ability to programmatically look up several types of entities by their name and other attributes. It attempts to match attributes that you supply for the entity and returns as many match candidates as it can find. The result is a \"concorded\" FactSet Entity Permanent identifier.  The Entity Identifier can then be used as input throughout FactSet's Content soultions, such as Content APIs and Standard DataFeeds.<p> There are types of workflows supported in the API. The first workflow type follows traditional API conventions in that a request is accepted and a response is returned synchronously. The second workflow type involves a background task. With this workflow, a task is created for uploading a set of queries, and then the client polls for the task to complete. Once the task has completed, the client retrieves the concordance results throught the decisions endpoint.</p> 
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using FactSet.SDK.FactSetConcordance.Client;
using FactSet.SDK.FactSetConcordance.Model;
using FactSet.SDK.Utils.Authentication;

namespace FactSet.SDK.FactSetConcordance.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IManageMappingsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// View Universe for the requesting user.
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>EntityUniverseResponse</returns>
        EntityUniverseResponse GetEntityUniverse(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?));

        /// <summary>
        /// View Universe for the requesting user.
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>ApiResponse of EntityUniverseResponse</returns>
        ApiResponse<EntityUniverseResponse> GetEntityUniverseWithHttpInfo(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?));
        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>EntityResponse</returns>
        EntityResponse SaveEntityMapping(EntityMappingRequest entityMappingRequest);

        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>ApiResponse of EntityResponse</returns>
        ApiResponse<EntityResponse> SaveEntityMappingWithHttpInfo(EntityMappingRequest entityMappingRequest);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IManageMappingsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// View Universe for the requesting user.
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityUniverseResponse</returns>
        System.Threading.Tasks.Task<EntityUniverseResponse> GetEntityUniverseAsync(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// View Universe for the requesting user.
        /// </summary>
        /// <remarks>
        /// Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityUniverseResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EntityUniverseResponse>> GetEntityUniverseWithHttpInfoAsync(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityResponse</returns>
        System.Threading.Tasks.Task<EntityResponse> SaveEntityMappingAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Saves a single-mapping specified by the client.
        /// </summary>
        /// <remarks>
        /// Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </remarks>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<EntityResponse>> SaveEntityMappingWithHttpInfoAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IManageMappingsApi : IManageMappingsApiSync, IManageMappingsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ManageMappingsApi : IManageMappingsApi
    {
        private FactSet.SDK.FactSetConcordance.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        # region Response Type Disctionaries
                private static readonly Dictionary<HttpStatusCode, System.Type> GetEntityUniverseResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EntityUniverseResponse) },
            { (HttpStatusCode)400, typeof(ErrorResponse) },
            { (HttpStatusCode)401, typeof(ErrorResponse) },
            { (HttpStatusCode)403, typeof(ErrorResponse) },
            { (HttpStatusCode)415, typeof(ErrorResponse) },
            { (HttpStatusCode)500, typeof(ErrorResponse) },
        };
        private static readonly Dictionary<HttpStatusCode, System.Type> SaveEntityMappingResponseTypeDictionary = new Dictionary<HttpStatusCode, System.Type>
        {
            { (HttpStatusCode)200, typeof(EntityResponse) },
            { (HttpStatusCode)400, typeof(ErrorResponse) },
            { (HttpStatusCode)401, typeof(ErrorResponse) },
            { (HttpStatusCode)403, typeof(ErrorResponse) },
            { (HttpStatusCode)415, typeof(ErrorResponse) },
            { (HttpStatusCode)500, typeof(ErrorResponse) },
        };

        # endregion Response Type Disctionaries

        # region Api Response Objects
         

        # endregion Api Response Objects

        /// <summary>
        /// Initializes a new instance of the <see cref="ManageMappingsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ManageMappingsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ManageMappingsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ManageMappingsApi(string basePath)
        {
            this.Configuration = FactSet.SDK.FactSetConcordance.Client.Configuration.MergeConfigurations(
                FactSet.SDK.FactSetConcordance.Client.GlobalConfiguration.Instance,
                new FactSet.SDK.FactSetConcordance.Client.Configuration { BasePath = basePath }
            );
            this.Client = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = FactSet.SDK.FactSetConcordance.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ManageMappingsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ManageMappingsApi(FactSet.SDK.FactSetConcordance.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = FactSet.SDK.FactSetConcordance.Client.Configuration.MergeConfigurations(
                FactSet.SDK.FactSetConcordance.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new FactSet.SDK.FactSetConcordance.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = FactSet.SDK.FactSetConcordance.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ManageMappingsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ManageMappingsApi(FactSet.SDK.FactSetConcordance.Client.ISynchronousClient client, FactSet.SDK.FactSetConcordance.Client.IAsynchronousClient asyncClient, FactSet.SDK.FactSetConcordance.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = FactSet.SDK.FactSetConcordance.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public FactSet.SDK.FactSetConcordance.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public FactSet.SDK.FactSetConcordance.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public FactSet.SDK.FactSetConcordance.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public FactSet.SDK.FactSetConcordance.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// View Universe for the requesting user. Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>EntityUniverseResponse</returns>
        public EntityUniverseResponse GetEntityUniverse(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?))
        {
            var localVarResponse = GetEntityUniverseWithHttpInfo(clientId, mapStatus, offset, limit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// View Universe for the requesting user. Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <returns>ApiResponse of EntityUniverseResponse</returns>
        public ApiResponse<EntityUniverseResponse> GetEntityUniverseWithHttpInfo(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?))
        {
            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (clientId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("csv", "clientId", clientId));
            }
            if (mapStatus != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("multi", "mapStatus", mapStatus));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = GetEntityUniverseResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Get<
            EntityUniverseResponse>("/factset-concordance/v1/entity-universe", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityUniverse", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// View Universe for the requesting user. Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityUniverseResponse</returns>
        public async System.Threading.Tasks.Task<EntityUniverseResponse>GetEntityUniverseAsync(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await GetEntityUniverseWithHttpInfoAsync(clientId, mapStatus, offset, limit, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// View Universe for the requesting user. Retrieves all entity mappings&#39; history made by the current user, or for a list of clientIds. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Filter by the clientId(s) created by the user in a previous mapping.  (optional)</param>
        /// <param name="mapStatus">Filter by the Entity Decisions that have the specified mapStatus, where -   * MAPPED - The requested Entity Name is successfully mapped to a FactSet Entity Id (-E)   * UNMAPPED - The requested Entity Name is unmapped by FactSet.   * INDETERMINATE - The requested Entity Name was unable to make a mapping.  (optional)</param>
        /// <param name="offset">Starting row for records to return or rows to skip. (optional, default to 0)</param>
        /// <param name="limit">Limits the number of records in the response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityUniverseResponse)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EntityUniverseResponse>> GetEntityUniverseWithHttpInfoAsync(List<string> clientId = default(List<string>), List<string> mapStatus = default(List<string>), int? offset = default(int?), int? limit = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (clientId != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("csv", "clientId", clientId));
            }
            if (mapStatus != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("multi", "mapStatus", mapStatus));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(FactSet.SDK.FactSetConcordance.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = GetEntityUniverseResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<EntityUniverseResponse>("/factset-concordance/v1/entity-universe", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEntityUniverse", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>EntityResponse</returns>
        public EntityResponse SaveEntityMapping(EntityMappingRequest entityMappingRequest)
        {
            var localVarResponse = SaveEntityMappingWithHttpInfo(entityMappingRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <returns>ApiResponse of EntityResponse</returns>
        public ApiResponse<EntityResponse> SaveEntityMappingWithHttpInfo(EntityMappingRequest entityMappingRequest)
        {
            // verify the required parameter 'entityMappingRequest' is set
            if (entityMappingRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityMappingRequest' when calling ManageMappingsApi->SaveEntityMapping");
            }

            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityMappingRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null)
            {
                var token = this.Configuration.OAuth2Client.GetAccessTokenAsync().Result;
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }

            localVarRequestOptions.ResponseTypeDictionary = SaveEntityMappingResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = this.Client.Post<
            EntityResponse>("/factset-concordance/v1/entity-mapping", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SaveEntityMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }
            return localVarResponse;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EntityResponse</returns>
        public async System.Threading.Tasks.Task<EntityResponse>SaveEntityMappingAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await SaveEntityMappingWithHttpInfoAsync(entityMappingRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Saves a single-mapping specified by the client. Saves a Concordance Mapping to the client universe. When making a post, all exiting values are overwritten in the database with the values passed in the request. clientId and clientName are required. 
        /// </summary>
        /// <exception cref="FactSet.SDK.FactSetConcordance.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityMappingRequest">A request to create a single mapping.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EntityResponse)</returns>

        public async System.Threading.Tasks.Task<ApiResponse<EntityResponse>> SaveEntityMappingWithHttpInfoAsync(EntityMappingRequest entityMappingRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'entityMappingRequest' is set
            if (entityMappingRequest == null)
            {
                throw new FactSet.SDK.FactSetConcordance.Client.ApiException(400, "Missing required parameter 'entityMappingRequest' when calling ManageMappingsApi->SaveEntityMapping");
            }


            FactSet.SDK.FactSetConcordance.Client.RequestOptions localVarRequestOptions = new FactSet.SDK.FactSetConcordance.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = FactSet.SDK.FactSetConcordance.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = entityMappingRequest;

            // authentication (FactSetApiKey) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + FactSet.SDK.FactSetConcordance.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (FactSetOAuth2) required
            // oauth required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // FactSet Authentication Client required
            if (this.Configuration.OAuth2Client != null) {
                var token = await this.Configuration.OAuth2Client.GetAccessTokenAsync();
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + token);
            }


            localVarRequestOptions.ResponseTypeDictionary = SaveEntityMappingResponseTypeDictionary;

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<EntityResponse>("/factset-concordance/v1/entity-mapping", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SaveEntityMapping", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
