/*
 * Open:Risk API
 *
 * Service to calculate parametric linear risk statistics and generate risk model asset identifier mappings.
 *
 * The version of the OpenAPI document: 1.21.0
 * Contact: ParametricRiskAnalyticsDevelopment@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.OpenRisk.Client.OpenAPIDateConverter;

namespace FactSet.SDK.OpenRisk.Model
{
    /// <summary>
    /// Settings to modify an individual statistic&#39;s calculation. See also [OA:17698](https://my.apps.factset.com/oa/pages/17698#risk) and [OA:16097](https://my.apps.factset.com/oa/pages/16097#cov2) for cov*2.
    /// </summary>
    [DataContract(Name = "StatCalculationSettings")]
    public partial class StatCalculationSettings : IEquatable<StatCalculationSettings>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StatCalculationSettings" /> class.
        /// </summary>
        /// <param name="useAbsoluteWeightsForLotExpansion">useAbsoluteWeightsForLotExpansion (default to true).</param>
        /// <param name="covarianceTimesTwo">covarianceTimesTwo (default to false).</param>
        /// <param name="covarianceTimesTwoTerm">covarianceTimesTwoTerm (default to false).</param>
        /// <param name="correlatedSpecificRisk">When this is set to true, specific risk correlation adjustment will be applied to security level as well as portfolio level. An example case where stock specific correlation is supplied by risk models is the case between parent equity and ADR. (default to false).</param>
        /// <param name="sparse">When this is set to true, the matrix and vector output is in compressed sparse row matrix format. Vector is considered as a matrix with one row for compressed sparse row matrix output. This only applies for matrix and vector output, not for single data points e.g. stats at Portfolio level. (default to false).</param>
        /// <param name="horizon">horizon.</param>
        /// <param name="daysPerYear">daysPerYear.</param>
        /// <param name="confidenceLevel">confidenceLevel.</param>
        /// <param name="lamda">lamda.</param>
        /// <param name="specificToFactorRatio">specificToFactorRatio.</param>
        /// <param name="rapSys">rapSys.</param>
        /// <param name="rapUnsys">rapUnsys.</param>
        public StatCalculationSettings(bool useAbsoluteWeightsForLotExpansion = true, bool covarianceTimesTwo = false, bool covarianceTimesTwoTerm = false, bool correlatedSpecificRisk = false, bool sparse = false, decimal horizon = default(decimal), decimal daysPerYear = default(decimal), decimal confidenceLevel = default(decimal), decimal lamda = default(decimal), decimal specificToFactorRatio = default(decimal), decimal rapSys = default(decimal), decimal rapUnsys = default(decimal))
        {
            this.UseAbsoluteWeightsForLotExpansion = useAbsoluteWeightsForLotExpansion;
            this.CovarianceTimesTwo = covarianceTimesTwo;
            this.CovarianceTimesTwoTerm = covarianceTimesTwoTerm;
            this.CorrelatedSpecificRisk = correlatedSpecificRisk;
            this.Sparse = sparse;
            this.Horizon = horizon;
            this.DaysPerYear = daysPerYear;
            this.ConfidenceLevel = confidenceLevel;
            this.Lamda = lamda;
            this.SpecificToFactorRatio = specificToFactorRatio;
            this.RapSys = rapSys;
            this.RapUnsys = rapUnsys;
        }

        /// <summary>
        /// Gets or Sets UseAbsoluteWeightsForLotExpansion
        /// </summary>
        [DataMember(Name = "useAbsoluteWeightsForLotExpansion", EmitDefaultValue = true)]
        public bool UseAbsoluteWeightsForLotExpansion { get; set; }

        /// <summary>
        /// Gets or Sets CovarianceTimesTwo
        /// </summary>
        [DataMember(Name = "covarianceTimesTwo", EmitDefaultValue = true)]
        public bool CovarianceTimesTwo { get; set; }

        /// <summary>
        /// Gets or Sets CovarianceTimesTwoTerm
        /// </summary>
        [DataMember(Name = "covarianceTimesTwoTerm", EmitDefaultValue = true)]
        public bool CovarianceTimesTwoTerm { get; set; }

        /// <summary>
        /// When this is set to true, specific risk correlation adjustment will be applied to security level as well as portfolio level. An example case where stock specific correlation is supplied by risk models is the case between parent equity and ADR.
        /// </summary>
        /// <value>When this is set to true, specific risk correlation adjustment will be applied to security level as well as portfolio level. An example case where stock specific correlation is supplied by risk models is the case between parent equity and ADR.</value>
        [DataMember(Name = "correlatedSpecificRisk", EmitDefaultValue = true)]
        public bool CorrelatedSpecificRisk { get; set; }

        /// <summary>
        /// When this is set to true, the matrix and vector output is in compressed sparse row matrix format. Vector is considered as a matrix with one row for compressed sparse row matrix output. This only applies for matrix and vector output, not for single data points e.g. stats at Portfolio level.
        /// </summary>
        /// <value>When this is set to true, the matrix and vector output is in compressed sparse row matrix format. Vector is considered as a matrix with one row for compressed sparse row matrix output. This only applies for matrix and vector output, not for single data points e.g. stats at Portfolio level.</value>
        [DataMember(Name = "sparse", EmitDefaultValue = true)]
        public bool Sparse { get; set; }

        /// <summary>
        /// Gets or Sets Horizon
        /// </summary>
        [DataMember(Name = "horizon", EmitDefaultValue = false)]
        public decimal Horizon { get; set; }

        /// <summary>
        /// Gets or Sets DaysPerYear
        /// </summary>
        [DataMember(Name = "daysPerYear", EmitDefaultValue = false)]
        public decimal DaysPerYear { get; set; }

        /// <summary>
        /// Gets or Sets ConfidenceLevel
        /// </summary>
        [DataMember(Name = "confidenceLevel", EmitDefaultValue = false)]
        public decimal ConfidenceLevel { get; set; }

        /// <summary>
        /// Gets or Sets Lamda
        /// </summary>
        [DataMember(Name = "lamda", EmitDefaultValue = false)]
        public decimal Lamda { get; set; }

        /// <summary>
        /// Gets or Sets SpecificToFactorRatio
        /// </summary>
        [DataMember(Name = "specificToFactorRatio", EmitDefaultValue = false)]
        public decimal SpecificToFactorRatio { get; set; }

        /// <summary>
        /// Gets or Sets RapSys
        /// </summary>
        [DataMember(Name = "rapSys", EmitDefaultValue = false)]
        public decimal RapSys { get; set; }

        /// <summary>
        /// Gets or Sets RapUnsys
        /// </summary>
        [DataMember(Name = "rapUnsys", EmitDefaultValue = false)]
        public decimal RapUnsys { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class StatCalculationSettings {\n");
            sb.Append("  UseAbsoluteWeightsForLotExpansion: ").Append(UseAbsoluteWeightsForLotExpansion).Append("\n");
            sb.Append("  CovarianceTimesTwo: ").Append(CovarianceTimesTwo).Append("\n");
            sb.Append("  CovarianceTimesTwoTerm: ").Append(CovarianceTimesTwoTerm).Append("\n");
            sb.Append("  CorrelatedSpecificRisk: ").Append(CorrelatedSpecificRisk).Append("\n");
            sb.Append("  Sparse: ").Append(Sparse).Append("\n");
            sb.Append("  Horizon: ").Append(Horizon).Append("\n");
            sb.Append("  DaysPerYear: ").Append(DaysPerYear).Append("\n");
            sb.Append("  ConfidenceLevel: ").Append(ConfidenceLevel).Append("\n");
            sb.Append("  Lamda: ").Append(Lamda).Append("\n");
            sb.Append("  SpecificToFactorRatio: ").Append(SpecificToFactorRatio).Append("\n");
            sb.Append("  RapSys: ").Append(RapSys).Append("\n");
            sb.Append("  RapUnsys: ").Append(RapUnsys).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StatCalculationSettings);
        }

        /// <summary>
        /// Returns true if StatCalculationSettings instances are equal
        /// </summary>
        /// <param name="input">Instance of StatCalculationSettings to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StatCalculationSettings input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.UseAbsoluteWeightsForLotExpansion == input.UseAbsoluteWeightsForLotExpansion ||
                    this.UseAbsoluteWeightsForLotExpansion.Equals(input.UseAbsoluteWeightsForLotExpansion)
                ) && 
                (
                    this.CovarianceTimesTwo == input.CovarianceTimesTwo ||
                    this.CovarianceTimesTwo.Equals(input.CovarianceTimesTwo)
                ) && 
                (
                    this.CovarianceTimesTwoTerm == input.CovarianceTimesTwoTerm ||
                    this.CovarianceTimesTwoTerm.Equals(input.CovarianceTimesTwoTerm)
                ) && 
                (
                    this.CorrelatedSpecificRisk == input.CorrelatedSpecificRisk ||
                    this.CorrelatedSpecificRisk.Equals(input.CorrelatedSpecificRisk)
                ) && 
                (
                    this.Sparse == input.Sparse ||
                    this.Sparse.Equals(input.Sparse)
                ) && 
                (
                    this.Horizon == input.Horizon ||
                    this.Horizon.Equals(input.Horizon)
                ) && 
                (
                    this.DaysPerYear == input.DaysPerYear ||
                    this.DaysPerYear.Equals(input.DaysPerYear)
                ) && 
                (
                    this.ConfidenceLevel == input.ConfidenceLevel ||
                    this.ConfidenceLevel.Equals(input.ConfidenceLevel)
                ) && 
                (
                    this.Lamda == input.Lamda ||
                    this.Lamda.Equals(input.Lamda)
                ) && 
                (
                    this.SpecificToFactorRatio == input.SpecificToFactorRatio ||
                    this.SpecificToFactorRatio.Equals(input.SpecificToFactorRatio)
                ) && 
                (
                    this.RapSys == input.RapSys ||
                    this.RapSys.Equals(input.RapSys)
                ) && 
                (
                    this.RapUnsys == input.RapUnsys ||
                    this.RapUnsys.Equals(input.RapUnsys)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.UseAbsoluteWeightsForLotExpansion.GetHashCode();
                hashCode = (hashCode * 59) + this.CovarianceTimesTwo.GetHashCode();
                hashCode = (hashCode * 59) + this.CovarianceTimesTwoTerm.GetHashCode();
                hashCode = (hashCode * 59) + this.CorrelatedSpecificRisk.GetHashCode();
                hashCode = (hashCode * 59) + this.Sparse.GetHashCode();
                hashCode = (hashCode * 59) + this.Horizon.GetHashCode();
                hashCode = (hashCode * 59) + this.DaysPerYear.GetHashCode();
                hashCode = (hashCode * 59) + this.ConfidenceLevel.GetHashCode();
                hashCode = (hashCode * 59) + this.Lamda.GetHashCode();
                hashCode = (hashCode * 59) + this.SpecificToFactorRatio.GetHashCode();
                hashCode = (hashCode * 59) + this.RapSys.GetHashCode();
                hashCode = (hashCode * 59) + this.RapUnsys.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
