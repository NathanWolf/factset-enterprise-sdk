/*
 * Prime Developer Trial
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.ETFProfileandPrices.Client.OpenAPIDateConverter;

namespace FactSet.SDK.ETFProfileandPrices.Model
{
    /// <summary>
    /// Portfolio statistics.
    /// </summary>
    [DataContract(Name = "inline_response_200_11_data")]
    public partial class InlineResponse20011Data : IEquatable<InlineResponse20011Data>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InlineResponse20011Data" /> class.
        /// </summary>
        /// <param name="asOfDate">Date the analytics data was published. Available for the regions: US, Europe, and Canada..</param>
        /// <param name="numberHoldings">A measure of portfolio diversification, calculated by summing the squared weights of each fund constituent. Low concentration implies high diversification, and vice versa. Outputs are Low, Medium or High. Available for regions: US..</param>
        /// <param name="concentration">A measure of portfolio diversification, calculated by summing the squared weights of each fund constituent. Low concentration implies high diversification, and vice versa. Possible values are Low, Medium or High. Available for regions: US..</param>
        /// <param name="dividendYield">The annualized weighted average of the current dividend yield of the portfolio&#39;s holdings, gross of fees. Available for the regions: US..</param>
        /// <param name="priceEarningsRatio">Weighted average ratio of prices of a fund’s stocks values to their trailing earnings of underlying stocks. Aggregate prices are scaled by the sum of individual earnings, including negative earnings. Available for the regions: US..</param>
        /// <param name="priceBookRatio">Weighted average ratio of prices of a fund’s stocks to the book value of underlying stocks. Aggregate prices are scaled by the sum of individual book values. Available for the regions: US..</param>
        /// <param name="marketCapitalization">The weighted average market capitalization of the stocks in the fund&#39;s portfolio (USD). Available for regions: US..</param>
        /// <param name="timeToMaturity">The weighted average of remaining time until maturity for all bonds in the portfolio, measured in (possibly fractional) years. Available for the regions: US..</param>
        /// <param name="creditRating">Average credit rating for the portfolio, determined by mapping ratings from credit agencies (Fitch, Moody&#39;s and Standard &amp; Poor&#39;s) to numerical likelihood of default for each bond in the portfolio and then finding the weighted average default probability, then mapping back to an agency credit rating. Accounts for the nonlinear probability of default when aggregating agency ratings. FactSet has developed a numeric equivalent system that allows math functions such as averaging and comparisons across sources (using greater than, equal to, or less than operators), to facilitate easier evaluation. Available for the regions: US..</param>
        public InlineResponse20011Data(DateTime asOfDate = default(DateTime), decimal numberHoldings = default(decimal), string concentration = default(string), decimal dividendYield = default(decimal), decimal priceEarningsRatio = default(decimal), decimal priceBookRatio = default(decimal), decimal marketCapitalization = default(decimal), decimal timeToMaturity = default(decimal), string creditRating = default(string))
        {
            this.AsOfDate = asOfDate;
            this.NumberHoldings = numberHoldings;
            this.Concentration = concentration;
            this.DividendYield = dividendYield;
            this.PriceEarningsRatio = priceEarningsRatio;
            this.PriceBookRatio = priceBookRatio;
            this.MarketCapitalization = marketCapitalization;
            this.TimeToMaturity = timeToMaturity;
            this.CreditRating = creditRating;
        }

        /// <summary>
        /// Date the analytics data was published. Available for the regions: US, Europe, and Canada.
        /// </summary>
        /// <value>Date the analytics data was published. Available for the regions: US, Europe, and Canada.</value>
        [DataMember(Name = "asOfDate", EmitDefaultValue = false)]
        [JsonConverter(typeof(OpenAPIDateConverter))]
        public DateTime AsOfDate { get; set; }

        /// <summary>
        /// A measure of portfolio diversification, calculated by summing the squared weights of each fund constituent. Low concentration implies high diversification, and vice versa. Outputs are Low, Medium or High. Available for regions: US.
        /// </summary>
        /// <value>A measure of portfolio diversification, calculated by summing the squared weights of each fund constituent. Low concentration implies high diversification, and vice versa. Outputs are Low, Medium or High. Available for regions: US.</value>
        [DataMember(Name = "numberHoldings", EmitDefaultValue = false)]
        public decimal NumberHoldings { get; set; }

        /// <summary>
        /// A measure of portfolio diversification, calculated by summing the squared weights of each fund constituent. Low concentration implies high diversification, and vice versa. Possible values are Low, Medium or High. Available for regions: US.
        /// </summary>
        /// <value>A measure of portfolio diversification, calculated by summing the squared weights of each fund constituent. Low concentration implies high diversification, and vice versa. Possible values are Low, Medium or High. Available for regions: US.</value>
        [DataMember(Name = "concentration", EmitDefaultValue = false)]
        public string Concentration { get; set; }

        /// <summary>
        /// The annualized weighted average of the current dividend yield of the portfolio&#39;s holdings, gross of fees. Available for the regions: US.
        /// </summary>
        /// <value>The annualized weighted average of the current dividend yield of the portfolio&#39;s holdings, gross of fees. Available for the regions: US.</value>
        [DataMember(Name = "dividendYield", EmitDefaultValue = false)]
        public decimal DividendYield { get; set; }

        /// <summary>
        /// Weighted average ratio of prices of a fund’s stocks values to their trailing earnings of underlying stocks. Aggregate prices are scaled by the sum of individual earnings, including negative earnings. Available for the regions: US.
        /// </summary>
        /// <value>Weighted average ratio of prices of a fund’s stocks values to their trailing earnings of underlying stocks. Aggregate prices are scaled by the sum of individual earnings, including negative earnings. Available for the regions: US.</value>
        [DataMember(Name = "priceEarningsRatio", EmitDefaultValue = false)]
        public decimal PriceEarningsRatio { get; set; }

        /// <summary>
        /// Weighted average ratio of prices of a fund’s stocks to the book value of underlying stocks. Aggregate prices are scaled by the sum of individual book values. Available for the regions: US.
        /// </summary>
        /// <value>Weighted average ratio of prices of a fund’s stocks to the book value of underlying stocks. Aggregate prices are scaled by the sum of individual book values. Available for the regions: US.</value>
        [DataMember(Name = "priceBookRatio", EmitDefaultValue = false)]
        public decimal PriceBookRatio { get; set; }

        /// <summary>
        /// The weighted average market capitalization of the stocks in the fund&#39;s portfolio (USD). Available for regions: US.
        /// </summary>
        /// <value>The weighted average market capitalization of the stocks in the fund&#39;s portfolio (USD). Available for regions: US.</value>
        [DataMember(Name = "marketCapitalization", EmitDefaultValue = false)]
        public decimal MarketCapitalization { get; set; }

        /// <summary>
        /// The weighted average of remaining time until maturity for all bonds in the portfolio, measured in (possibly fractional) years. Available for the regions: US.
        /// </summary>
        /// <value>The weighted average of remaining time until maturity for all bonds in the portfolio, measured in (possibly fractional) years. Available for the regions: US.</value>
        [DataMember(Name = "timeToMaturity", EmitDefaultValue = false)]
        public decimal TimeToMaturity { get; set; }

        /// <summary>
        /// Average credit rating for the portfolio, determined by mapping ratings from credit agencies (Fitch, Moody&#39;s and Standard &amp; Poor&#39;s) to numerical likelihood of default for each bond in the portfolio and then finding the weighted average default probability, then mapping back to an agency credit rating. Accounts for the nonlinear probability of default when aggregating agency ratings. FactSet has developed a numeric equivalent system that allows math functions such as averaging and comparisons across sources (using greater than, equal to, or less than operators), to facilitate easier evaluation. Available for the regions: US.
        /// </summary>
        /// <value>Average credit rating for the portfolio, determined by mapping ratings from credit agencies (Fitch, Moody&#39;s and Standard &amp; Poor&#39;s) to numerical likelihood of default for each bond in the portfolio and then finding the weighted average default probability, then mapping back to an agency credit rating. Accounts for the nonlinear probability of default when aggregating agency ratings. FactSet has developed a numeric equivalent system that allows math functions such as averaging and comparisons across sources (using greater than, equal to, or less than operators), to facilitate easier evaluation. Available for the regions: US.</value>
        [DataMember(Name = "creditRating", EmitDefaultValue = false)]
        public string CreditRating { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class InlineResponse20011Data {\n");
            sb.Append("  AsOfDate: ").Append(AsOfDate).Append("\n");
            sb.Append("  NumberHoldings: ").Append(NumberHoldings).Append("\n");
            sb.Append("  Concentration: ").Append(Concentration).Append("\n");
            sb.Append("  DividendYield: ").Append(DividendYield).Append("\n");
            sb.Append("  PriceEarningsRatio: ").Append(PriceEarningsRatio).Append("\n");
            sb.Append("  PriceBookRatio: ").Append(PriceBookRatio).Append("\n");
            sb.Append("  MarketCapitalization: ").Append(MarketCapitalization).Append("\n");
            sb.Append("  TimeToMaturity: ").Append(TimeToMaturity).Append("\n");
            sb.Append("  CreditRating: ").Append(CreditRating).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as InlineResponse20011Data);
        }

        /// <summary>
        /// Returns true if InlineResponse20011Data instances are equal
        /// </summary>
        /// <param name="input">Instance of InlineResponse20011Data to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InlineResponse20011Data input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.AsOfDate == input.AsOfDate ||
                    (this.AsOfDate != null &&
                    this.AsOfDate.Equals(input.AsOfDate))
                ) && 
                (
                    this.NumberHoldings == input.NumberHoldings ||
                    this.NumberHoldings.Equals(input.NumberHoldings)
                ) && 
                (
                    this.Concentration == input.Concentration ||
                    (this.Concentration != null &&
                    this.Concentration.Equals(input.Concentration))
                ) && 
                (
                    this.DividendYield == input.DividendYield ||
                    this.DividendYield.Equals(input.DividendYield)
                ) && 
                (
                    this.PriceEarningsRatio == input.PriceEarningsRatio ||
                    this.PriceEarningsRatio.Equals(input.PriceEarningsRatio)
                ) && 
                (
                    this.PriceBookRatio == input.PriceBookRatio ||
                    this.PriceBookRatio.Equals(input.PriceBookRatio)
                ) && 
                (
                    this.MarketCapitalization == input.MarketCapitalization ||
                    this.MarketCapitalization.Equals(input.MarketCapitalization)
                ) && 
                (
                    this.TimeToMaturity == input.TimeToMaturity ||
                    this.TimeToMaturity.Equals(input.TimeToMaturity)
                ) && 
                (
                    this.CreditRating == input.CreditRating ||
                    (this.CreditRating != null &&
                    this.CreditRating.Equals(input.CreditRating))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.AsOfDate != null)
                {
                    hashCode = (hashCode * 59) + this.AsOfDate.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.NumberHoldings.GetHashCode();
                if (this.Concentration != null)
                {
                    hashCode = (hashCode * 59) + this.Concentration.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.DividendYield.GetHashCode();
                hashCode = (hashCode * 59) + this.PriceEarningsRatio.GetHashCode();
                hashCode = (hashCode * 59) + this.PriceBookRatio.GetHashCode();
                hashCode = (hashCode * 59) + this.MarketCapitalization.GetHashCode();
                hashCode = (hashCode * 59) + this.TimeToMaturity.GetHashCode();
                if (this.CreditRating != null)
                {
                    hashCode = (hashCode * 59) + this.CreditRating.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
