/*
 * Prime Developer Trial
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = FactSet.SDK.ETFProfileandPrices.Client.OpenAPIDateConverter;

namespace FactSet.SDK.ETFProfileandPrices.Model
{
    /// <summary>
    /// Properties of the ETP with respect to large trades.
    /// </summary>
    [DataContract(Name = "inline_response_200_13_data_blockTrade")]
    public partial class InlineResponse20013DataBlockTrade : IEquatable<InlineResponse20013DataBlockTrade>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InlineResponse20013DataBlockTrade" /> class.
        /// </summary>
        /// <param name="overlapHours">A measurement of the overlap between the hours of trading for the ETF and that of its underlying portfolio. Available for the regions: US..</param>
        /// <param name="underlyingVolumePerUnit">Weighted average of the ratios of each underlying&#39;s number of shares, represented in one creation unit of the ETP, relative to the median daily trading volume of the underlying over 45 trading days, expressed as a percentage. This is a measure of the liquidity available in the underlying portfolio of the ETP, whereby larger numbers indicate greater likelihood of adverse price impact on underlying securities from ETF creations/redemptions. Only applicable for ETF. Available for the regions: US..</param>
        /// <param name="liquidity">A measurement of the liquidity available in an ETF for a hypothetical 1,000,000 USD trade. Measured on a scale of 0 to 5 - - 5 being very liquid and easy to execute, 1 being expensive and difficult to execute, and 0 indicating a closed or restricted creation window. Available for the regions: US..</param>
        /// <param name="creationUnitPerDay">The median 45 day share volume divided by the creation unit size of the fund. The higher the number, the more likely that liquidity providers will trade the fund in size, or in odd lots. Available for the regions: US..</param>
        public InlineResponse20013DataBlockTrade(decimal overlapHours = default(decimal), decimal underlyingVolumePerUnit = default(decimal), decimal liquidity = default(decimal), decimal creationUnitPerDay = default(decimal))
        {
            this.OverlapHours = overlapHours;
            this.UnderlyingVolumePerUnit = underlyingVolumePerUnit;
            this.Liquidity = liquidity;
            this.CreationUnitPerDay = creationUnitPerDay;
        }

        /// <summary>
        /// A measurement of the overlap between the hours of trading for the ETF and that of its underlying portfolio. Available for the regions: US.
        /// </summary>
        /// <value>A measurement of the overlap between the hours of trading for the ETF and that of its underlying portfolio. Available for the regions: US.</value>
        [DataMember(Name = "overlapHours", EmitDefaultValue = false)]
        public decimal OverlapHours { get; set; }

        /// <summary>
        /// Weighted average of the ratios of each underlying&#39;s number of shares, represented in one creation unit of the ETP, relative to the median daily trading volume of the underlying over 45 trading days, expressed as a percentage. This is a measure of the liquidity available in the underlying portfolio of the ETP, whereby larger numbers indicate greater likelihood of adverse price impact on underlying securities from ETF creations/redemptions. Only applicable for ETF. Available for the regions: US.
        /// </summary>
        /// <value>Weighted average of the ratios of each underlying&#39;s number of shares, represented in one creation unit of the ETP, relative to the median daily trading volume of the underlying over 45 trading days, expressed as a percentage. This is a measure of the liquidity available in the underlying portfolio of the ETP, whereby larger numbers indicate greater likelihood of adverse price impact on underlying securities from ETF creations/redemptions. Only applicable for ETF. Available for the regions: US.</value>
        [DataMember(Name = "underlyingVolumePerUnit", EmitDefaultValue = false)]
        public decimal UnderlyingVolumePerUnit { get; set; }

        /// <summary>
        /// A measurement of the liquidity available in an ETF for a hypothetical 1,000,000 USD trade. Measured on a scale of 0 to 5 - - 5 being very liquid and easy to execute, 1 being expensive and difficult to execute, and 0 indicating a closed or restricted creation window. Available for the regions: US.
        /// </summary>
        /// <value>A measurement of the liquidity available in an ETF for a hypothetical 1,000,000 USD trade. Measured on a scale of 0 to 5 - - 5 being very liquid and easy to execute, 1 being expensive and difficult to execute, and 0 indicating a closed or restricted creation window. Available for the regions: US.</value>
        [DataMember(Name = "liquidity", EmitDefaultValue = false)]
        public decimal Liquidity { get; set; }

        /// <summary>
        /// The median 45 day share volume divided by the creation unit size of the fund. The higher the number, the more likely that liquidity providers will trade the fund in size, or in odd lots. Available for the regions: US.
        /// </summary>
        /// <value>The median 45 day share volume divided by the creation unit size of the fund. The higher the number, the more likely that liquidity providers will trade the fund in size, or in odd lots. Available for the regions: US.</value>
        [DataMember(Name = "creationUnitPerDay", EmitDefaultValue = false)]
        public decimal CreationUnitPerDay { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class InlineResponse20013DataBlockTrade {\n");
            sb.Append("  OverlapHours: ").Append(OverlapHours).Append("\n");
            sb.Append("  UnderlyingVolumePerUnit: ").Append(UnderlyingVolumePerUnit).Append("\n");
            sb.Append("  Liquidity: ").Append(Liquidity).Append("\n");
            sb.Append("  CreationUnitPerDay: ").Append(CreationUnitPerDay).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as InlineResponse20013DataBlockTrade);
        }

        /// <summary>
        /// Returns true if InlineResponse20013DataBlockTrade instances are equal
        /// </summary>
        /// <param name="input">Instance of InlineResponse20013DataBlockTrade to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(InlineResponse20013DataBlockTrade input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.OverlapHours == input.OverlapHours ||
                    this.OverlapHours.Equals(input.OverlapHours)
                ) && 
                (
                    this.UnderlyingVolumePerUnit == input.UnderlyingVolumePerUnit ||
                    this.UnderlyingVolumePerUnit.Equals(input.UnderlyingVolumePerUnit)
                ) && 
                (
                    this.Liquidity == input.Liquidity ||
                    this.Liquidity.Equals(input.Liquidity)
                ) && 
                (
                    this.CreationUnitPerDay == input.CreationUnitPerDay ||
                    this.CreationUnitPerDay.Equals(input.CreationUnitPerDay)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.OverlapHours.GetHashCode();
                hashCode = (hashCode * 59) + this.UnderlyingVolumePerUnit.GetHashCode();
                hashCode = (hashCode * 59) + this.Liquidity.GetHashCode();
                hashCode = (hashCode * 59) + this.CreationUnitPerDay.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
