/**
 * EMS API
 * Allow clients to trade orders.
 *
 * The version of the OpenAPI document: 0.3.0
 * Contact: api@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Instrument from './Instrument';
import TimeInForce from './TimeInForce';

/**
 * The EMSOrder model module.
 * @module model/EMSOrder
 */
class EMSOrder {
    /**
     * Constructs a new <code>EMSOrder</code>.
     * EMS Order
     * @alias module:model/EMSOrder
     * @param instrument {module:model/Instrument} 
     * @param side {module:model/EMSOrder.SideEnum} Side of the order.
     * @param orderType {module:model/EMSOrder.OrderTypeEnum} Type of the order
     */
    constructor(instrument, side, orderType) { 
        
        EMSOrder.initialize(this, instrument, side, orderType);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, instrument, side, orderType) { 
        obj['instrument'] = instrument;
        obj['side'] = side;
        obj['orderType'] = orderType;
    }

    /**
     * Constructs a <code>EMSOrder</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/EMSOrder} obj Optional instance to populate.
     * @return {module:model/EMSOrder} The populated <code>EMSOrder</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new EMSOrder();

            if (data.hasOwnProperty('clientOrderId')) {
                obj['clientOrderId'] = ApiClient.convertToType(data['clientOrderId'], 'String');
            }
            if (data.hasOwnProperty('instrument')) {
                obj['instrument'] = Instrument.constructFromObject(data['instrument']);
            }
            if (data.hasOwnProperty('side')) {
                obj['side'] = ApiClient.convertToType(data['side'], 'String');
            }
            if (data.hasOwnProperty('orderType')) {
                obj['orderType'] = ApiClient.convertToType(data['orderType'], 'String');
            }
            if (data.hasOwnProperty('orderQuantity')) {
                obj['orderQuantity'] = ApiClient.convertToType(data['orderQuantity'], 'Number');
            }
            if (data.hasOwnProperty('price')) {
                obj['price'] = ApiClient.convertToType(data['price'], 'Number');
            }
            if (data.hasOwnProperty('stopPrice')) {
                obj['stopPrice'] = ApiClient.convertToType(data['stopPrice'], 'Number');
            }
            if (data.hasOwnProperty('strikePrice')) {
                obj['strikePrice'] = ApiClient.convertToType(data['strikePrice'], 'Number');
            }
            if (data.hasOwnProperty('currency')) {
                obj['currency'] = ApiClient.convertToType(data['currency'], 'String');
            }
            if (data.hasOwnProperty('isCovered')) {
                obj['isCovered'] = ApiClient.convertToType(data['isCovered'], 'Boolean');
            }
            if (data.hasOwnProperty('maxShow')) {
                obj['maxShow'] = ApiClient.convertToType(data['maxShow'], 'Number');
            }
            if (data.hasOwnProperty('maxFloor')) {
                obj['maxFloor'] = ApiClient.convertToType(data['maxFloor'], 'Number');
            }
            if (data.hasOwnProperty('prevClosePrice')) {
                obj['prevClosePrice'] = ApiClient.convertToType(data['prevClosePrice'], 'Number');
            }
            if (data.hasOwnProperty('settlementType')) {
                obj['settlementType'] = ApiClient.convertToType(data['settlementType'], 'String');
            }
            if (data.hasOwnProperty('settlementDate')) {
                obj['settlementDate'] = ApiClient.convertToType(data['settlementDate'], 'String');
            }
            if (data.hasOwnProperty('handlingInstructions')) {
                obj['handlingInstructions'] = ApiClient.convertToType(data['handlingInstructions'], 'String');
            }
            if (data.hasOwnProperty('executionInstructions')) {
                obj['executionInstructions'] = ApiClient.convertToType(data['executionInstructions'], 'String');
            }
            if (data.hasOwnProperty('locateRequired')) {
                obj['locateRequired'] = ApiClient.convertToType(data['locateRequired'], 'Boolean');
            }
            if (data.hasOwnProperty('effectiveTime')) {
                obj['effectiveTime'] = ApiClient.convertToType(data['effectiveTime'], 'String');
            }
            if (data.hasOwnProperty('account')) {
                obj['account'] = ApiClient.convertToType(data['account'], 'String');
            }
            if (data.hasOwnProperty('timeInForce')) {
                obj['timeInForce'] = TimeInForce.constructFromObject(data['timeInForce']);
            }
            if (data.hasOwnProperty('inboundDestination')) {
                obj['inboundDestination'] = ApiClient.convertToType(data['inboundDestination'], 'String');
            }
            if (data.hasOwnProperty('userDefinedFields')) {
                obj['userDefinedFields'] = ApiClient.convertToType(data['userDefinedFields'], {'String': 'String'});
            }
        }
        return obj;
    }


}

/**
 * Unique id for the order
 * @member {String} clientOrderId
 */
EMSOrder.prototype['clientOrderId'] = undefined;

/**
 * @member {module:model/Instrument} instrument
 */
EMSOrder.prototype['instrument'] = undefined;

/**
 * Side of the order.
 * @member {module:model/EMSOrder.SideEnum} side
 */
EMSOrder.prototype['side'] = undefined;

/**
 * Type of the order
 * @member {module:model/EMSOrder.OrderTypeEnum} orderType
 */
EMSOrder.prototype['orderType'] = undefined;

/**
 * Number of shares/Quantity.
 * @member {Number} orderQuantity
 */
EMSOrder.prototype['orderQuantity'] = undefined;

/**
 * Order price per share
 * @member {Number} price
 */
EMSOrder.prototype['price'] = undefined;

/**
 * Stop-loss price to buy/sell stock at market.
 * @member {Number} stopPrice
 */
EMSOrder.prototype['stopPrice'] = undefined;

/**
 * Strike Price for an Option.
 * @member {Number} strikePrice
 */
EMSOrder.prototype['strikePrice'] = undefined;

/**
 * Currency used for price in ISO format.
 * @member {String} currency
 */
EMSOrder.prototype['currency'] = undefined;

/**
 * Signifies if a specific order is a covered order. A covered order is one that involves an investment strategy with the capability to limit the potential loss of the order.
 * @member {Boolean} isCovered
 */
EMSOrder.prototype['isCovered'] = undefined;

/**
 * Maximum number of shares within an order to be shown to other customers.
 * @member {Number} maxShow
 */
EMSOrder.prototype['maxShow'] = undefined;

/**
 * Maximum number of shares within an order to be shown on the exchange floor at any given time.
 * @member {Number} maxFloor
 */
EMSOrder.prototype['maxFloor'] = undefined;

/**
 * Previous closing price of security.
 * @member {Number} prevClosePrice
 */
EMSOrder.prototype['prevClosePrice'] = undefined;

/**
 * Order settlement period.
 * @member {module:model/EMSOrder.SettlementTypeEnum} settlementType
 */
EMSOrder.prototype['settlementType'] = undefined;

/**
 * Settlement date of trade settlement in YYYYMMDD format
 * @member {String} settlementDate
 */
EMSOrder.prototype['settlementDate'] = undefined;

/**
 * Instructions for order handling on Broker trading floor.
 * @member {module:model/EMSOrder.HandlingInstructionsEnum} handlingInstructions
 */
EMSOrder.prototype['handlingInstructions'] = undefined;

/**
 * Instructions for order handling on exchange trading floor.
 * @member {module:model/EMSOrder.ExecutionInstructionsEnum} executionInstructions
 */
EMSOrder.prototype['executionInstructions'] = undefined;

/**
 * Indicates whether the broker is to locate the stock in conjunction with a short sell order.
 * @member {Boolean} locateRequired
 */
EMSOrder.prototype['locateRequired'] = undefined;

/**
 * Effective time in YYYYMMDD-HH:MM:SS format expressed in UTC
 * @member {String} effectiveTime
 */
EMSOrder.prototype['effectiveTime'] = undefined;

/**
 * Account for the basket, parent basket or position.
 * @member {String} account
 */
EMSOrder.prototype['account'] = undefined;

/**
 * @member {module:model/TimeInForce} timeInForce
 */
EMSOrder.prototype['timeInForce'] = undefined;

/**
 * To facilitate integration with translators that transform orders into a format compatible with the internal order routing and execution infrastructure.
 * @member {String} inboundDestination
 */
EMSOrder.prototype['inboundDestination'] = undefined;

/**
 * User defined fields
 * @member {Object.<String, String>} userDefinedFields
 */
EMSOrder.prototype['userDefinedFields'] = undefined;





/**
 * Allowed values for the <code>side</code> property.
 * @enum {String}
 * @readonly
 */
EMSOrder['SideEnum'] = {

    /**
     * value: "buy"
     * @const
     */
    "buy": "buy",

    /**
     * value: "sell"
     * @const
     */
    "sell": "sell",

    /**
     * value: "sellShort"
     * @const
     */
    "sellShort": "sellShort",

    /**
     * value: "sellShortExempt"
     * @const
     */
    "sellShortExempt": "sellShortExempt"
};


/**
 * Allowed values for the <code>orderType</code> property.
 * @enum {String}
 * @readonly
 */
EMSOrder['OrderTypeEnum'] = {

    /**
     * value: "market"
     * @const
     */
    "market": "market",

    /**
     * value: "limit"
     * @const
     */
    "limit": "limit",

    /**
     * value: "stop"
     * @const
     */
    "stop": "stop",

    /**
     * value: "stopLimit"
     * @const
     */
    "stopLimit": "stopLimit",

    /**
     * value: "marketOnClose"
     * @const
     */
    "marketOnClose": "marketOnClose",

    /**
     * value: "limitOrBetter"
     * @const
     */
    "limitOrBetter": "limitOrBetter"
};


/**
 * Allowed values for the <code>settlementType</code> property.
 * @enum {String}
 * @readonly
 */
EMSOrder['SettlementTypeEnum'] = {

    /**
     * value: "regular"
     * @const
     */
    "regular": "regular",

    /**
     * value: "cash"
     * @const
     */
    "cash": "cash",

    /**
     * value: "nextDay"
     * @const
     */
    "nextDay": "nextDay",

    /**
     * value: "tPlus2"
     * @const
     */
    "tPlus2": "tPlus2",

    /**
     * value: "tPlus3"
     * @const
     */
    "tPlus3": "tPlus3",

    /**
     * value: "tPlus4"
     * @const
     */
    "tPlus4": "tPlus4",

    /**
     * value: "future"
     * @const
     */
    "future": "future",

    /**
     * value: "whenIssued"
     * @const
     */
    "whenIssued": "whenIssued",

    /**
     * value: "sellersOption"
     * @const
     */
    "sellersOption": "sellersOption",

    /**
     * value: "tPlus5"
     * @const
     */
    "tPlus5": "tPlus5"
};


/**
 * Allowed values for the <code>handlingInstructions</code> property.
 * @enum {String}
 * @readonly
 */
EMSOrder['HandlingInstructionsEnum'] = {

    /**
     * value: "autoOrderPrivate"
     * @const
     */
    "autoOrderPrivate": "autoOrderPrivate",

    /**
     * value: "autoOrderPublic"
     * @const
     */
    "autoOrderPublic": "autoOrderPublic",

    /**
     * value: "bestExecution"
     * @const
     */
    "bestExecution": "bestExecution"
};


/**
 * Allowed values for the <code>executionInstructions</code> property.
 * @enum {String}
 * @readonly
 */
EMSOrder['ExecutionInstructionsEnum'] = {

    /**
     * value: "notHeld"
     * @const
     */
    "notHeld": "notHeld",

    /**
     * value: "work"
     * @const
     */
    "work": "work",

    /**
     * value: "goAlong"
     * @const
     */
    "goAlong": "goAlong",

    /**
     * value: "overTheDay"
     * @const
     */
    "overTheDay": "overTheDay",

    /**
     * value: "held"
     * @const
     */
    "held": "held",

    /**
     * value: "participateDoNotInitiate"
     * @const
     */
    "participateDoNotInitiate": "participateDoNotInitiate",

    /**
     * value: "strictScale"
     * @const
     */
    "strictScale": "strictScale",

    /**
     * value: "tryToScale"
     * @const
     */
    "tryToScale": "tryToScale",

    /**
     * value: "stayOnBidSide"
     * @const
     */
    "stayOnBidSide": "stayOnBidSide",

    /**
     * value: "stayOnOfferSide"
     * @const
     */
    "stayOnOfferSide": "stayOnOfferSide",

    /**
     * value: "noCross"
     * @const
     */
    "noCross": "noCross",

    /**
     * value: "okToCross"
     * @const
     */
    "okToCross": "okToCross",

    /**
     * value: "callFirst"
     * @const
     */
    "callFirst": "callFirst",

    /**
     * value: "percentOfVolume"
     * @const
     */
    "percentOfVolume": "percentOfVolume",

    /**
     * value: "doNotIncrease"
     * @const
     */
    "doNotIncrease": "doNotIncrease",

    /**
     * value: "doNotReduce"
     * @const
     */
    "doNotReduce": "doNotReduce",

    /**
     * value: "allOrNone"
     * @const
     */
    "allOrNone": "allOrNone",

    /**
     * value: "reinstateOnSystemFailure"
     * @const
     */
    "reinstateOnSystemFailure": "reinstateOnSystemFailure",

    /**
     * value: "institutionsOnly"
     * @const
     */
    "institutionsOnly": "institutionsOnly",

    /**
     * value: "reinstateOnTradingHalt"
     * @const
     */
    "reinstateOnTradingHalt": "reinstateOnTradingHalt",

    /**
     * value: "cancelOnTradingHalt"
     * @const
     */
    "cancelOnTradingHalt": "cancelOnTradingHalt",

    /**
     * value: "lastPeg"
     * @const
     */
    "lastPeg": "lastPeg",

    /**
     * value: "midPricePeg"
     * @const
     */
    "midPricePeg": "midPricePeg",

    /**
     * value: "nonNegotiable"
     * @const
     */
    "nonNegotiable": "nonNegotiable",

    /**
     * value: "openingPeg"
     * @const
     */
    "openingPeg": "openingPeg",

    /**
     * value: "marketPeg"
     * @const
     */
    "marketPeg": "marketPeg",

    /**
     * value: "cancelOnSystemFailure"
     * @const
     */
    "cancelOnSystemFailure": "cancelOnSystemFailure",

    /**
     * value: "primaryPeg"
     * @const
     */
    "primaryPeg": "primaryPeg",

    /**
     * value: "suspend"
     * @const
     */
    "suspend": "suspend",

    /**
     * value: "fixedPegToLocalBestBid"
     * @const
     */
    "fixedPegToLocalBestBid": "fixedPegToLocalBestBid",

    /**
     * value: "customerDisplayInstruction"
     * @const
     */
    "customerDisplayInstruction": "customerDisplayInstruction",

    /**
     * value: "netting"
     * @const
     */
    "netting": "netting",

    /**
     * value: "pegToVWAP"
     * @const
     */
    "pegToVWAP": "pegToVWAP",

    /**
     * value: "tradeAlong"
     * @const
     */
    "tradeAlong": "tradeAlong",

    /**
     * value: "tryToStop"
     * @const
     */
    "tryToStop": "tryToStop",

    /**
     * value: "cancelIfNotBest"
     * @const
     */
    "cancelIfNotBest": "cancelIfNotBest",

    /**
     * value: "trailingStopPeg"
     * @const
     */
    "trailingStopPeg": "trailingStopPeg",

    /**
     * value: "strictLimit"
     * @const
     */
    "strictLimit": "strictLimit",

    /**
     * value: "ignorePriceValidityChecks"
     * @const
     */
    "ignorePriceValidityChecks": "ignorePriceValidityChecks",

    /**
     * value: "pegToLimitPrice"
     * @const
     */
    "pegToLimitPrice": "pegToLimitPrice",

    /**
     * value: "workToTargetStrategy"
     * @const
     */
    "workToTargetStrategy": "workToTargetStrategy",

    /**
     * value: "intermarketSweep"
     * @const
     */
    "intermarketSweep": "intermarketSweep",

    /**
     * value: "externalRoutingAllowed"
     * @const
     */
    "externalRoutingAllowed": "externalRoutingAllowed",

    /**
     * value: "externalRoutingNotAllowed"
     * @const
     */
    "externalRoutingNotAllowed": "externalRoutingNotAllowed",

    /**
     * value: "imbalanceOnly"
     * @const
     */
    "imbalanceOnly": "imbalanceOnly",

    /**
     * value: "singleExecutionRequestedForBlockTrade"
     * @const
     */
    "singleExecutionRequestedForBlockTrade": "singleExecutionRequestedForBlockTrade",

    /**
     * value: "bestExecution"
     * @const
     */
    "bestExecution": "bestExecution"
};



export default EMSOrder;

