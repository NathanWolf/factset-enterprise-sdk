/*
 * Prime Developer Trial
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.StocksAPIforDigitalPortals.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.StocksAPIforDigitalPortals.JSON;


/**
 * List of indices of which a stock is a constituent. The list restricts the request to return only those stocks that are a constituent of one of the specified indices.
 */
@ApiModel(description = "List of indices of which a stock is a constituent. The list restricts the request to return only those stocks that are a constituent of one of the specified indices.")
@JsonPropertyOrder({
  StockNotationRankingIntradayListDataIndexMembership.JSON_PROPERTY_IDS,
  StockNotationRankingIntradayListDataIndexMembership.JSON_PROPERTY_USE_ALTERNATIVE_NOTATION
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class StockNotationRankingIntradayListDataIndexMembership implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String JSON_PROPERTY_IDS = "ids";
  private java.util.Set<String> ids = null;

  public static final String JSON_PROPERTY_USE_ALTERNATIVE_NOTATION = "useAlternativeNotation";
  private Boolean useAlternativeNotation = false;

  public StockNotationRankingIntradayListDataIndexMembership() { 
  }

  public StockNotationRankingIntradayListDataIndexMembership ids(java.util.Set<String> ids) {
    this.ids = ids;
    return this;
  }

  public StockNotationRankingIntradayListDataIndexMembership addIdsItem(String idsItem) {
    if (this.ids == null) {
      this.ids = new java.util.LinkedHashSet<>();
    }
    this.ids.add(idsItem);
    return this;
  }

   /**
   * List of index instrument identifiers.
   * @return ids
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "List of index instrument identifiers.")
  @JsonProperty(JSON_PROPERTY_IDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public java.util.Set<String> getIds() {
    return ids;
  }


  @JsonProperty(JSON_PROPERTY_IDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIds(java.util.Set<String> ids) {
    this.ids = ids;
  }


  public StockNotationRankingIntradayListDataIndexMembership useAlternativeNotation(Boolean useAlternativeNotation) {
    this.useAlternativeNotation = useAlternativeNotation;
    return this;
  }

   /**
   * Specifies whether an alternative notation of a constituent shall be retrieved if the market of the original notation is currently closed or if the user is not entitled for the market of the original notation. The alternative notation is the one with the highest trading volume averaged over one month that satisfies all other selected filters, such as only a specific market or a specific currency. If the original notation is not entitled and a currency has not been specified, the alternative notation may be in a different currency than the original one which makes the ranking less meaningful, especially a trading value-based ranking, see attribute &#x60;accumulated.tradingValue&#x60; in the response.
   * @return useAlternativeNotation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies whether an alternative notation of a constituent shall be retrieved if the market of the original notation is currently closed or if the user is not entitled for the market of the original notation. The alternative notation is the one with the highest trading volume averaged over one month that satisfies all other selected filters, such as only a specific market or a specific currency. If the original notation is not entitled and a currency has not been specified, the alternative notation may be in a different currency than the original one which makes the ranking less meaningful, especially a trading value-based ranking, see attribute `accumulated.tradingValue` in the response.")
  @JsonProperty(JSON_PROPERTY_USE_ALTERNATIVE_NOTATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getUseAlternativeNotation() {
    return useAlternativeNotation;
  }


  @JsonProperty(JSON_PROPERTY_USE_ALTERNATIVE_NOTATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUseAlternativeNotation(Boolean useAlternativeNotation) {
    this.useAlternativeNotation = useAlternativeNotation;
  }


  /**
   * Return true if this _stock_notation_ranking_intraday_list_data_indexMembership object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StockNotationRankingIntradayListDataIndexMembership stockNotationRankingIntradayListDataIndexMembership = (StockNotationRankingIntradayListDataIndexMembership) o;
    return Objects.equals(this.ids, stockNotationRankingIntradayListDataIndexMembership.ids) &&
        Objects.equals(this.useAlternativeNotation, stockNotationRankingIntradayListDataIndexMembership.useAlternativeNotation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ids, useAlternativeNotation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StockNotationRankingIntradayListDataIndexMembership {\n");
    sb.append("    ids: ").append(toIndentedString(ids)).append("\n");
    sb.append("    useAlternativeNotation: ").append(toIndentedString(useAlternativeNotation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

