/*
 * Open:Risk API
 * Service to calculate parametric linear risk statistics and generate risk model asset identifier mappings.
 *
 * The version of the OpenAPI document: 1.23.0
 * Contact: ParametricRiskAnalyticsDevelopment@factset.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.factset.sdk.OpenRisk.models;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.factset.sdk.OpenRisk.models.SupportedStatsLevels;
import com.factset.sdk.OpenRisk.models.SupportedStatsSecurityGroupMethod;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.factset.sdk.OpenRisk.JSON;


/**
 * SupportedStatsData
 */
@JsonPropertyOrder({
  SupportedStatsData.JSON_PROPERTY_CORRELATED_SPECIFIC_RISK,
  SupportedStatsData.JSON_PROPERTY_COVARIANCE_TIMES_TWO,
  SupportedStatsData.JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK,
  SupportedStatsData.JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO,
  SupportedStatsData.JSON_PROPERTY_DERIVED,
  SupportedStatsData.JSON_PROPERTY_LEVELS,
  SupportedStatsData.JSON_PROPERTY_SECURITY_GROUP_METHOD,
  SupportedStatsData.JSON_PROPERTY_SECURITY_LOT_ALLOCATION
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class SupportedStatsData implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String JSON_PROPERTY_CORRELATED_SPECIFIC_RISK = "correlatedSpecificRisk";
  private Boolean correlatedSpecificRisk;

  public static final String JSON_PROPERTY_COVARIANCE_TIMES_TWO = "covarianceTimesTwo";
  private Boolean covarianceTimesTwo;

  public static final String JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK = "requiresCorrelatedSpecificRisk";
  private Boolean requiresCorrelatedSpecificRisk;

  public static final String JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO = "requiresCovarianceTimesTwo";
  private Boolean requiresCovarianceTimesTwo;

  public static final String JSON_PROPERTY_DERIVED = "derived";
  private java.util.List<String> derived = new java.util.ArrayList<>();

  public static final String JSON_PROPERTY_LEVELS = "levels";
  private SupportedStatsLevels levels;

  public static final String JSON_PROPERTY_SECURITY_GROUP_METHOD = "securityGroupMethod";
  private SupportedStatsSecurityGroupMethod securityGroupMethod;

  /**
   * Indicates the weights according to which securities with multiple lots have their risk statistic values allocated. &#39;FillAll&#39; indicates the computed statistic value of a particular security is allocated to each of its lots equally. This is common for risk statistics such as marginal statistics or beta. If security group calculations are available, these weights will be used along with &#39;weighting&#39; method specified in &#39;securityGroupMethod&#39;. For example, if this is &#39;ActiveWeights&#39; and &#39;weighting&#39; is &#39;AbsoluteValue&#39;, a net position value is allocated to multiple lots based off of absolute active weights distribution.
   */
  public enum SecurityLotAllocationEnum {
    PORTFOLIOWEIGHTS("PortfolioWeights"),
    
    BENCHMARKWEIGHTS("BenchmarkWeights"),
    
    ACTIVEWEIGHTS("ActiveWeights"),
    
    MARKETWEIGHTS("MarketWeights"),
    
    FILLALL("FillAll");

    private String value;

    SecurityLotAllocationEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static SecurityLotAllocationEnum fromValue(String value) {
      for (SecurityLotAllocationEnum b : SecurityLotAllocationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_SECURITY_LOT_ALLOCATION = "securityLotAllocation";
  private SecurityLotAllocationEnum securityLotAllocation;

  public SupportedStatsData() { 
  }

  @JsonCreator
  public SupportedStatsData(
    @JsonProperty(value=JSON_PROPERTY_CORRELATED_SPECIFIC_RISK, required=true) Boolean correlatedSpecificRisk, 
    @JsonProperty(value=JSON_PROPERTY_COVARIANCE_TIMES_TWO, required=true) Boolean covarianceTimesTwo, 
    @JsonProperty(value=JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK, required=true) Boolean requiresCorrelatedSpecificRisk, 
    @JsonProperty(value=JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO, required=true) Boolean requiresCovarianceTimesTwo, 
    @JsonProperty(value=JSON_PROPERTY_DERIVED, required=true) java.util.List<String> derived, 
    @JsonProperty(value=JSON_PROPERTY_LEVELS, required=true) SupportedStatsLevels levels
  ) {
    this();
    this.correlatedSpecificRisk = correlatedSpecificRisk;
    this.covarianceTimesTwo = covarianceTimesTwo;
    this.requiresCorrelatedSpecificRisk = requiresCorrelatedSpecificRisk;
    this.requiresCovarianceTimesTwo = requiresCovarianceTimesTwo;
    this.derived = derived;
    this.levels = levels;
  }

  public SupportedStatsData correlatedSpecificRisk(Boolean correlatedSpecificRisk) {
    this.correlatedSpecificRisk = correlatedSpecificRisk;
    return this;
  }

   /**
   * Get correlatedSpecificRisk
   * @return correlatedSpecificRisk
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getCorrelatedSpecificRisk() {
    return correlatedSpecificRisk;
  }


  @JsonProperty(JSON_PROPERTY_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCorrelatedSpecificRisk(Boolean correlatedSpecificRisk) {
    this.correlatedSpecificRisk = correlatedSpecificRisk;
  }


  public SupportedStatsData covarianceTimesTwo(Boolean covarianceTimesTwo) {
    this.covarianceTimesTwo = covarianceTimesTwo;
    return this;
  }

   /**
   * Get covarianceTimesTwo
   * @return covarianceTimesTwo
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getCovarianceTimesTwo() {
    return covarianceTimesTwo;
  }


  @JsonProperty(JSON_PROPERTY_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCovarianceTimesTwo(Boolean covarianceTimesTwo) {
    this.covarianceTimesTwo = covarianceTimesTwo;
  }


  public SupportedStatsData requiresCorrelatedSpecificRisk(Boolean requiresCorrelatedSpecificRisk) {
    this.requiresCorrelatedSpecificRisk = requiresCorrelatedSpecificRisk;
    return this;
  }

   /**
   * Get requiresCorrelatedSpecificRisk
   * @return requiresCorrelatedSpecificRisk
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getRequiresCorrelatedSpecificRisk() {
    return requiresCorrelatedSpecificRisk;
  }


  @JsonProperty(JSON_PROPERTY_REQUIRES_CORRELATED_SPECIFIC_RISK)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRequiresCorrelatedSpecificRisk(Boolean requiresCorrelatedSpecificRisk) {
    this.requiresCorrelatedSpecificRisk = requiresCorrelatedSpecificRisk;
  }


  public SupportedStatsData requiresCovarianceTimesTwo(Boolean requiresCovarianceTimesTwo) {
    this.requiresCovarianceTimesTwo = requiresCovarianceTimesTwo;
    return this;
  }

   /**
   * Get requiresCovarianceTimesTwo
   * @return requiresCovarianceTimesTwo
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getRequiresCovarianceTimesTwo() {
    return requiresCovarianceTimesTwo;
  }


  @JsonProperty(JSON_PROPERTY_REQUIRES_COVARIANCE_TIMES_TWO)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRequiresCovarianceTimesTwo(Boolean requiresCovarianceTimesTwo) {
    this.requiresCovarianceTimesTwo = requiresCovarianceTimesTwo;
  }


  public SupportedStatsData derived(java.util.List<String> derived) {
    this.derived = derived;
    return this;
  }

  public SupportedStatsData addDerivedItem(String derivedItem) {
    this.derived.add(derivedItem);
    return this;
  }

   /**
   * A list of the base stat and all possible derived stats which are currently supported by the service.
   * @return derived
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "A list of the base stat and all possible derived stats which are currently supported by the service.")
  @JsonProperty(JSON_PROPERTY_DERIVED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public java.util.List<String> getDerived() {
    return derived;
  }


  @JsonProperty(JSON_PROPERTY_DERIVED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDerived(java.util.List<String> derived) {
    this.derived = derived;
  }


  public SupportedStatsData levels(SupportedStatsLevels levels) {
    this.levels = levels;
    return this;
  }

   /**
   * Get levels
   * @return levels
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(JSON_PROPERTY_LEVELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public SupportedStatsLevels getLevels() {
    return levels;
  }


  @JsonProperty(JSON_PROPERTY_LEVELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLevels(SupportedStatsLevels levels) {
    this.levels = levels;
  }


  public SupportedStatsData securityGroupMethod(SupportedStatsSecurityGroupMethod securityGroupMethod) {
    this.securityGroupMethod = securityGroupMethod;
    return this;
  }

   /**
   * Get securityGroupMethod
   * @return securityGroupMethod
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_SECURITY_GROUP_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SupportedStatsSecurityGroupMethod getSecurityGroupMethod() {
    return securityGroupMethod;
  }


  @JsonProperty(JSON_PROPERTY_SECURITY_GROUP_METHOD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSecurityGroupMethod(SupportedStatsSecurityGroupMethod securityGroupMethod) {
    this.securityGroupMethod = securityGroupMethod;
  }


  public SupportedStatsData securityLotAllocation(SecurityLotAllocationEnum securityLotAllocation) {
    this.securityLotAllocation = securityLotAllocation;
    return this;
  }

   /**
   * Indicates the weights according to which securities with multiple lots have their risk statistic values allocated. &#39;FillAll&#39; indicates the computed statistic value of a particular security is allocated to each of its lots equally. This is common for risk statistics such as marginal statistics or beta. If security group calculations are available, these weights will be used along with &#39;weighting&#39; method specified in &#39;securityGroupMethod&#39;. For example, if this is &#39;ActiveWeights&#39; and &#39;weighting&#39; is &#39;AbsoluteValue&#39;, a net position value is allocated to multiple lots based off of absolute active weights distribution.
   * @return securityLotAllocation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Indicates the weights according to which securities with multiple lots have their risk statistic values allocated. 'FillAll' indicates the computed statistic value of a particular security is allocated to each of its lots equally. This is common for risk statistics such as marginal statistics or beta. If security group calculations are available, these weights will be used along with 'weighting' method specified in 'securityGroupMethod'. For example, if this is 'ActiveWeights' and 'weighting' is 'AbsoluteValue', a net position value is allocated to multiple lots based off of absolute active weights distribution.")
  @JsonProperty(JSON_PROPERTY_SECURITY_LOT_ALLOCATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SecurityLotAllocationEnum getSecurityLotAllocation() {
    return securityLotAllocation;
  }


  @JsonProperty(JSON_PROPERTY_SECURITY_LOT_ALLOCATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSecurityLotAllocation(SecurityLotAllocationEnum securityLotAllocation) {
    this.securityLotAllocation = securityLotAllocation;
  }


  /**
   * Return true if this SupportedStats_data object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SupportedStatsData supportedStatsData = (SupportedStatsData) o;
    return Objects.equals(this.correlatedSpecificRisk, supportedStatsData.correlatedSpecificRisk) &&
        Objects.equals(this.covarianceTimesTwo, supportedStatsData.covarianceTimesTwo) &&
        Objects.equals(this.requiresCorrelatedSpecificRisk, supportedStatsData.requiresCorrelatedSpecificRisk) &&
        Objects.equals(this.requiresCovarianceTimesTwo, supportedStatsData.requiresCovarianceTimesTwo) &&
        Objects.equals(this.derived, supportedStatsData.derived) &&
        Objects.equals(this.levels, supportedStatsData.levels) &&
        Objects.equals(this.securityGroupMethod, supportedStatsData.securityGroupMethod) &&
        Objects.equals(this.securityLotAllocation, supportedStatsData.securityLotAllocation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(correlatedSpecificRisk, covarianceTimesTwo, requiresCorrelatedSpecificRisk, requiresCovarianceTimesTwo, derived, levels, securityGroupMethod, securityLotAllocation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SupportedStatsData {\n");
    sb.append("    correlatedSpecificRisk: ").append(toIndentedString(correlatedSpecificRisk)).append("\n");
    sb.append("    covarianceTimesTwo: ").append(toIndentedString(covarianceTimesTwo)).append("\n");
    sb.append("    requiresCorrelatedSpecificRisk: ").append(toIndentedString(requiresCorrelatedSpecificRisk)).append("\n");
    sb.append("    requiresCovarianceTimesTwo: ").append(toIndentedString(requiresCovarianceTimesTwo)).append("\n");
    sb.append("    derived: ").append(toIndentedString(derived)).append("\n");
    sb.append("    levels: ").append(toIndentedString(levels)).append("\n");
    sb.append("    securityGroupMethod: ").append(toIndentedString(securityGroupMethod)).append("\n");
    sb.append("    securityLotAllocation: ").append(toIndentedString(securityLotAllocation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

